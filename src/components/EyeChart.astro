---
const contentItems = [
  { year: 2025, title: "Future Design Systems", slug: "/projects/future-design", type: "project" },
  { year: 2024, title: "AI Interface Study", slug: "/case-studies/ai-interface", type: "case-study" },
  { year: 2024, title: "Typography Research", slug: "/blog/typography-research", type: "blog" },
  { year: 2024, title: "User Experience Patterns", slug: "/projects/ux-patterns", type: "project" },
  { year: 2023, title: "Design Token Workshop", slug: "/blog/design-tokens", type: "blog" },
  { year: 2023, title: "Component Architecture", slug: "/projects/component-arch", type: "project" },
  { year: 2023, title: "Accessibility Audit", slug: "/case-studies/a11y-audit", type: "case-study" },
  { year: 2022, title: "Creative Coding Experiments", slug: "/blog/creative-coding", type: "blog" },
  { year: 2022, title: "Brand Identity System", slug: "/projects/brand-identity", type: "project" },
  { year: 2022, title: "Mobile App Redesign", slug: "/case-studies/mobile-redesign", type: "case-study" },
  { year: 2021, title: "Design System Migration", slug: "/projects/design-migration", type: "project" },
  { year: 2021, title: "User Research Methods", slug: "/blog/research-methods", type: "blog" },
  { year: 2020, title: "Remote Design Process", slug: "/blog/remote-design", type: "blog" }
];

function getYearDisplay(currentItem, index) {
  return '';
}

function getLettersFromTitle(title) {
  return title.toUpperCase().replace(/[^A-Z]/g, '').substring(0, 5).split('');
}
---

<div class="eye-chart-container">
  <div class="eye-chart">
    {contentItems.map((item, index) => {
      const letters = getLettersFromTitle(item.title);
      const yearDisplay = getYearDisplay(item, index);
      const lineNumber = index + 1;
      
      return (
        <a href={item.slug} class={`chart-line line-${lineNumber} content-link`} data-type={item.type} title={item.title}>
          <div class="letters-container">
            {letters.map((letter, letterIndex) => (
              <span data-letter={letter} key={letterIndex}>{letter}</span>
            ))}
          </div>
        </a>
      );
    })}
    
    <div class="drawer-trigger-wrapper">
      <div class="letters-container">
        <div class="drawer-trigger" id="drawer-trigger">
          <div class="solid-block">ABOUT NOLAN</div>
        </div>
      </div>
    </div>
    
    <div class="copyright-line">
      <div class="copyright-content letters-container">
        <div class="copyright-main">
          <span class="copyright-symbol">©</span>
          <div class="copyright-text-group">
            <span class="copyright-year">2025</span>
            <span class="copyright-text">ALL RIGHTS RESERVED</span>
          </div>
        </div>
        <div class="copyright-care">MADE WITH CARE</div>
      </div>
    </div>
  </div>
  
</div>

<style>
  .eye-chart-container {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100vw;
    height: 100vh;
    margin: 0;
    background: white;
    padding: clamp(1.5rem, 3vw, 2.5rem);
    font-family: 'Neue Haas Grotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    font-weight: 700;
    box-sizing: border-box;
  }
  
  
  .eye-chart {
    width: auto;
    max-width: 100%;
    max-height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
  }
  
  @media (orientation: landscape) {
    .eye-chart {
      width: 56.25vh;
      max-width: 56.25vh;
    }
  }
  
  @media (orientation: portrait) {
    .eye-chart {
      width: 100%;
      max-width: 100vw;
    }
  }
  
  .eye-chart {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: clamp(0.2rem, 0.8vw, 0.8rem);
    position: relative;
    width: auto;
    height: auto;
    justify-content: center;
  }
  
  .chart-line {
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: 700;
    letter-spacing: 0.05em;
    white-space: nowrap;
    width: 100%;
    text-decoration: none;
    color: inherit;
    transition: all 0.3s ease;
  }
  
  .content-link:hover {
    transform: translateX(4px);
  }
  
  .content-link:hover .line-number {
    color: #666 !important;
  }
  
  .content-link::after {
    content: '↗';
    position: absolute;
    right: -2rem;
    opacity: 0;
    transform: translateX(-10px);
    transition: all 0.3s ease;
    font-size: 1.2em;
    color: #666;
    pointer-events: none;
  }
  
  .content-link:hover::after {
    opacity: 1;
    transform: translateX(0);
  }
  
  .line-number {
    color: #000000 !important;
    font-family: 'Evolve Sans', sans-serif !important;
    font-weight: 400 !important;
    font-size: 0.8rem !important;
    margin-right: max(1rem, 1.5em) !important;
    width: 2em !important;
    text-align: left !important;
    flex-shrink: 0 !important;
    opacity: 1 !important;
    display: inline-block !important;
    position: relative !important;
    z-index: 10 !important;
  }
  
  .letters-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 0.5em;
    width: auto;
  }
  
  .chart-line span {
    display: inline-block;
    text-align: center;
    color: transparent;
    line-height: 1;
    position: relative;
    --clarity: 0;
    animation: fadeIn 0.3s ease forwards;
    opacity: 0;
  }
  
  @keyframes fadeIn {
    to {
      opacity: 1;
    }
  }
  
  .chart-line span::before,
  .chart-line span::after {
    content: attr(data-letter);
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    transition: all 0.1s ease;
  }
  
  .chart-line span::before {
    color: #FF0000;
    transform: translateX(calc(-0.05em * (1 - var(--clarity))));
    mix-blend-mode: multiply;
    opacity: calc(1 - var(--clarity));
  }
  
  .chart-line span::after {
    color: #00FFFF;
    transform: translateX(calc(0.05em * (1 - var(--clarity))));
    mix-blend-mode: multiply;
    opacity: calc(1 - var(--clarity));
  }
  
  .chart-line span {
    color: rgba(0, 0, 0, var(--clarity));
  }
  
  .chart-line span.glitching {
    transition: none !important;
  }
  
  .chart-line span.glitching::before,
  .chart-line span.glitching::after {
    transition: none !important;
  }
  
  .line-1 {
    font-size: 5rem;
  }
  
  .line-2 {
    font-size: 4rem;
  }
  
  .line-3 {
    font-size: 3.2rem;
  }
  
  .line-4 {
    font-size: 2.6rem;
  }
  
  .line-5 {
    font-size: 2.1rem;
  }
  
  .line-6 {
    font-size: 1.7rem;
  }
  
  .line-7 {
    font-size: 1.4rem;
  }
  
  .line-8 {
    font-size: 1.1rem;
  }
  
  .line-9 {
    font-size: 0.9rem;
  }
  
  .line-10 {
    font-size: 0.75rem;
  }
  
  .line-11 {
    font-size: 0.6rem;
  }
  
  .line-12 {
    font-size: 0.5rem;
  }
  
  .line-13 {
    font-size: 0.4rem;
  }
  
  .drawer-trigger-wrapper {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
  }
  
  .drawer-trigger-wrapper .line-number {
    width: 2em;
    margin-right: 1.5em;
    flex-shrink: 0;
    visibility: hidden;
  }
  
  .drawer-trigger {
    cursor: pointer;
    transition: all 0.3s ease;
    display: inline-flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    transform: translateY(20px);
    animation: slideUpButton 0.6s ease forwards;
    animation-delay: 2.5s;
  }
  
  @keyframes slideUpButton {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  .drawer-trigger:hover {
    transform: translateY(-2px);
  }
  
  .solid-block {
    background: #000 !important;
    color: #fff !important;
    padding: 0.8rem 2rem;
    border-radius: 0;
    font-size: 1rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    transition: all 0.3s ease;
    width: auto;
    text-align: center;
    box-shadow: none !important;
    text-shadow: none !important;
    position: relative;
    display: inline-block;
  }
  
  .solid-block::before,
  .solid-block::after {
    display: none !important;
  }
  
  .drawer-trigger:hover .solid-block {
    background: #333 !important;
    transform: translateY(-1px);
  }
  
  .copyright-line {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    margin-top: auto;
  }
  
  .copyright-line .line-number {
    width: 2em;
    margin-right: 1.5em;
    flex-shrink: 0;
    visibility: hidden;
  }
  
  .copyright-content {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    width: auto;
    font-size: clamp(0.75rem, 1.2vw, 0.9rem);
    font-weight: 500;
    color: #000;
    letter-spacing: 0.05em;
    margin-top: 1rem;
    font-family: 'Evolve Sans', sans-serif;
    text-transform: uppercase;
    line-height: 1.1;
  }
  
  .copyright-main {
    display: flex;
    align-items: center;
    gap: 0.3em;
    opacity: 0.7;
  }
  
  .copyright-text-group {
    display: flex;
    align-items: center;
    gap: 0.3em;
  }
  
  .copyright-care {
    margin-top: 0.5em;
  }
  
  .copyright-symbol {
    font-size: 1.2em;
    font-weight: 600;
  }
  
  .copyright-year {
    font-weight: 600;
    color: #000;
  }
  
  .copyright-text {
    font-size: 1em;
    letter-spacing: 0.05em;
  }
  
  .copyright-care {
    font-size: 1em;
    font-style: normal;
    color: #000;
    letter-spacing: 0.05em;
  }
  
  @media (max-width: 768px) {
    .eye-chart-container {
      padding: 1rem;
    }
  }
  
  @media (max-width: 480px) {
    .eye-chart-container {
      padding: 1rem;
    }
    
    .copyright-line {
      gap: 0.2em;
      flex-wrap: wrap;
    }
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const container = document.querySelector('.eye-chart-container');
    const letters = document.querySelectorAll('.content-link span[data-letter]');
    const PROXIMITY_THRESHOLD = 150; // Distance threshold for clearing effect
    
    // Scramble animation on load
    const CHAR_POOL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    
    function scrambleInLetter(element: HTMLElement) {
      const finalLetter = element.getAttribute('data-original');
      const duration = 800 + Math.random() * 400; // 800-1200ms per letter
      const startTime = Date.now();
      let frameCount = 0;
      
      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        if (progress < 1) {
          // Scramble phase - change character every few frames for better effect
          frameCount++;
          if (frameCount % 3 === 0) { // Change every 3 frames
            const randomChar = CHAR_POOL[Math.floor(Math.random() * CHAR_POOL.length)];
            element.textContent = randomChar;
            element.setAttribute('data-letter', randomChar);
          }
          requestAnimationFrame(animate);
        } else {
          // Final letter
          element.textContent = finalLetter;
          element.setAttribute('data-letter', finalLetter);
        }
      }
      
      animate();
    }
    
    // Stagger the scramble animation for each letter
    letters.forEach((letter, index) => {
      // Store original letter
      const originalLetter = letter.getAttribute('data-letter');
      letter.setAttribute('data-original', originalLetter);
      
      // Set initial random character
      const randomChar = CHAR_POOL[Math.floor(Math.random() * CHAR_POOL.length)];
      letter.textContent = randomChar;
      letter.setAttribute('data-letter', randomChar);
      
      // Trigger fade in and scramble with stagger
      const delay = index * 30; // 30ms stagger between each letter
      setTimeout(() => {
        (letter as HTMLElement).style.opacity = '1';
        scrambleInLetter(letter as HTMLElement);
      }, delay);
    });
    
    function updateLetterClarity(mouseX: number, mouseY: number, _isTouchDevice = false) {
      letters.forEach(letter => {
        const rect = letter.getBoundingClientRect();
        const letterCenterX = rect.left + rect.width / 2;
        const letterCenterY = rect.top + rect.height / 2;
        
        // Calculate distance from cursor/touch to letter center
        const distance = Math.sqrt(
          Math.pow(mouseX - letterCenterX, 2) + 
          Math.pow(mouseY - letterCenterY, 2)
        );
        
        // Calculate clarity based on proximity (0 = anaglyphic, 1 = clear)
        const clarity = Math.max(0, Math.min(1, 1 - (distance / PROXIMITY_THRESHOLD)));
        
        // Apply the effect using CSS custom properties
        (letter as HTMLElement).style.setProperty('--clarity', clarity.toString());
        
        // Apply clearing class for smooth transition
        if (clarity > 0.1) {
          letter.classList.add('clearing');
        } else {
          letter.classList.remove('clearing');
        }
      });
    }
    
    // Mouse move handler for cursor devices
    container.addEventListener('mousemove', function(e: MouseEvent) {
      updateLetterClarity(e.clientX, e.clientY);
    });
    
    // Touch move handler for touch devices
    container.addEventListener('touchmove', function(e: TouchEvent) {
      e.preventDefault();
      const touch = e.touches[0];
      updateLetterClarity(touch.clientX, touch.clientY, true);
    }, { passive: false });
    
    // Touch start handler for touch devices
    container.addEventListener('touchstart', function(e: TouchEvent) {
      const touch = e.touches[0];
      updateLetterClarity(touch.clientX, touch.clientY, true);
    });
    
    // Reset when mouse leaves (cursor devices)
    container.addEventListener('mouseleave', function() {
      letters.forEach(letter => {
        letter.classList.remove('clearing');
        (letter as HTMLElement).style.removeProperty('--clarity');
      });
    });
    
    // Reset when touch ends (touch devices)
    container.addEventListener('touchend', function() {
      letters.forEach(letter => {
        letter.classList.remove('clearing');
        (letter as HTMLElement).style.removeProperty('--clarity');
      });
    });
    
    // Idle glitch effect
    let idleTimer = null;
    // let _glitchInterval: number | null = null;
    let currentGlitchingLetter = null;
    
    function startIdleGlitch() {
      // Select a random letter that's not currently being interacted with
      const availableLetters = Array.from(letters).filter(letter => 
        !letter.classList.contains('clearing') && letter.getAttribute('data-letter')
      );
      
      if (availableLetters.length === 0) return;
      
      // Clear any existing glitch
      if (currentGlitchingLetter) {
        currentGlitchingLetter.style.setProperty('--clarity', '0');
        currentGlitchingLetter.classList.remove('glitching');
      }
      
      // Pick a random letter
      currentGlitchingLetter = availableLetters[Math.floor(Math.random() * availableLetters.length)];
      currentGlitchingLetter.classList.add('glitching');
      
      // Glitch animation - oscillate clarity
      // let _glitchPhase = 0;
      const glitchDuration = 2000; // 2 seconds per glitch
      const startTime = Date.now();
      
      function animateGlitch() {
        const elapsed = Date.now() - startTime;
        
        if (elapsed < glitchDuration) {
          // Create glitchy oscillation between clear and anaglyphic
          const progress = elapsed / glitchDuration;
          const glitchValue = Math.random() > 0.5 ? 
            Math.sin(progress * Math.PI * 8) * 0.5 + 0.5 : // Smooth oscillation
            Math.random(); // Random glitch
          
          currentGlitchingLetter.style.setProperty('--clarity', glitchValue);
          requestAnimationFrame(animateGlitch);
        } else {
          // End glitch, return to anaglyphic state
          currentGlitchingLetter.style.setProperty('--clarity', '0');
          currentGlitchingLetter.classList.remove('glitching');
          
          // Schedule next glitch after a pause
          setTimeout(() => {
            if (idleTimer) startIdleGlitch();
          }, 1000 + Math.random() * 2000); // 1-3 seconds between glitches
        }
      }
      
      animateGlitch();
    }
    
    function resetIdleTimer() {
      // Clear existing timers
      if (idleTimer) {
        clearTimeout(idleTimer);
        idleTimer = null;
      }
      
      // Stop any active glitching
      if (currentGlitchingLetter) {
        currentGlitchingLetter.style.setProperty('--clarity', '0');
        currentGlitchingLetter.classList.remove('glitching');
        currentGlitchingLetter = null;
      }
      
      // Start new idle timer
      idleTimer = setTimeout(() => {
        startIdleGlitch();
      }, 3000); // 3 seconds of idle before glitching starts
    }
    
    // Track user activity
    container.addEventListener('mousemove', resetIdleTimer);
    container.addEventListener('mouseenter', resetIdleTimer);
    container.addEventListener('touchstart', resetIdleTimer);
    container.addEventListener('touchmove', resetIdleTimer);
    document.addEventListener('click', resetIdleTimer);
    
    // Start the idle timer initially
    resetIdleTimer();
  });
</script>