---
---

<div class="eye-chart-container">
  <div class="eye-chart">
    <div class="chart-line line-1">
      <span data-letter="H">H</span>
      <span data-letter="V">V</span>
      <span data-letter="Z">Z</span>
      <span data-letter="D">D</span>
      <span data-letter="S">S</span>
    </div>
    
    <div class="chart-line line-2">
      <span data-letter="N">N</span>
      <span data-letter="C">C</span>
      <span data-letter="V">V</span>
      <span data-letter="K">K</span>
      <span data-letter="D">D</span>
    </div>
    
    <div class="chart-line line-3">
      <span data-letter="C">C</span>
      <span data-letter="Z">Z</span>
      <span data-letter="S">S</span>
      <span data-letter="H">H</span>
      <span data-letter="N">N</span>
    </div>
    
    <div class="chart-line line-4">
      <span data-letter="O">O</span>
      <span data-letter="N">N</span>
      <span data-letter="V">V</span>
      <span data-letter="S">S</span>
      <span data-letter="R">R</span>
    </div>
    
    <div class="chart-line line-5">
      <span data-letter="K">K</span>
      <span data-letter="D">D</span>
      <span data-letter="N">N</span>
      <span data-letter="R">R</span>
      <span data-letter="O">O</span>
    </div>
    
    <div class="chart-line line-6">
      <span data-letter="Z">Z</span>
      <span data-letter="K">K</span>
      <span data-letter="C">C</span>
      <span data-letter="S">S</span>
      <span data-letter="V">V</span>
    </div>
    
    <div class="chart-line line-7">
      <span data-letter="D">D</span>
      <span data-letter="V">V</span>
      <span data-letter="O">O</span>
      <span data-letter="H">H</span>
      <span data-letter="C">C</span>
    </div>
    
    <div class="chart-line line-8">
      <span data-letter="O">O</span>
      <span data-letter="H">H</span>
      <span data-letter="V">V</span>
      <span data-letter="C">C</span>
      <span data-letter="K">K</span>
    </div>
    
    <div class="chart-line line-9">
      <span data-letter="H">H</span>
      <span data-letter="Z">Z</span>
      <span data-letter="C">C</span>
      <span data-letter="K">K</span>
      <span data-letter="O">O</span>
    </div>
    
    <div class="chart-line line-10">
      <span data-letter="N">N</span>
      <span data-letter="C">C</span>
      <span data-letter="K">K</span>
      <span data-letter="N">N</span>
      <span data-letter="D">D</span>
    </div>
    
    <div class="chart-line line-11">
      <span data-letter="Z">Z</span>
      <span data-letter="H">H</span>
      <span data-letter="C">C</span>
      <span data-letter="S">S</span>
      <span data-letter="R">R</span>
    </div>
    
    <div class="chart-line line-12">
      <span data-letter="S">S</span>
      <span data-letter="Z">Z</span>
      <span data-letter="R">R</span>
      <span data-letter="D">D</span>
      <span data-letter="N">N</span>
    </div>
    
    <div class="chart-line line-13">
      <span data-letter="H">H</span>
      <span data-letter="C">C</span>
      <span data-letter="D">D</span>
      <span data-letter="R">R</span>
      <span data-letter="O">O</span>
    </div>
    
    <div class="drawer-trigger" id="drawer-trigger">
      <div class="solid-block">SEE MORE</div>
    </div>
  </div>
  
</div>

<style>
  .eye-chart-container {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100vw;
    height: 100vh;
    margin: 0;
    background: 
      repeating-conic-gradient(
        from 0deg at 50% 50%,
        rgba(255, 182, 193, 0.3) 0deg 90deg,
        white 90deg 180deg,
        rgba(255, 182, 193, 0.3) 180deg 270deg,
        white 270deg 360deg
      );
    background-size: 20px 20px;
    padding: min(4vw, 3rem);
    font-family: 'Bebas Neue', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    box-sizing: border-box;
  }
  
  /* Custom cursor for devices with precise pointers */
  @media (hover: hover) and (pointer: fine) {
    .eye-chart-container {
      cursor: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTQiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJyZ2JhKDI1NSwyNTUsMjU1LDAuMikiLz4KPGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTAiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIi8+CjxsaW5lIHgxPSIyNy41IiB5MT0iMjcuNSIgeDI9IjM1IiB5Mj0iMzUiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIzIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz4KPC9zdmc+') 20 20, auto;
    }
  }
  
  
  .eye-chart {
    width: 100%;
    max-width: 100vw;
    max-height: 100vh;
  }
  
  @media (orientation: landscape) {
    .eye-chart {
      width: 56.25vh;
      max-width: 56.25vh;
    }
  }
  
  @media (orientation: portrait) {
    .eye-chart {
      width: 100%;
      max-width: 100vw;
    }
  }
  
  .eye-chart {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: clamp(0.2rem, 0.8vw, 0.8rem);
    position: relative;
    width: 100%;
    height: 100%;
    justify-content: space-evenly;
  }
  
  .chart-line {
    display: flex;
    justify-content: center;
    gap: 0.5em;
    font-weight: 700;
    letter-spacing: 0.05em;
    white-space: nowrap;
  }
  
  .chart-line span {
    display: inline-block;
    text-align: center;
    color: transparent;
    line-height: 1;
    position: relative;
    --clarity: 0;
    animation: fadeIn 0.3s ease forwards;
    opacity: 0;
  }
  
  @keyframes fadeIn {
    to {
      opacity: 1;
    }
  }
  
  .chart-line span::before,
  .chart-line span::after {
    content: attr(data-letter);
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    transition: all 0.1s ease;
  }
  
  .chart-line span::before {
    color: #FF0000;
    transform: translateX(calc(-0.05em * (1 - var(--clarity))));
    mix-blend-mode: multiply;
    opacity: calc(1 - var(--clarity));
  }
  
  .chart-line span::after {
    color: #00FFFF;
    transform: translateX(calc(0.05em * (1 - var(--clarity))));
    mix-blend-mode: multiply;
    opacity: calc(1 - var(--clarity));
  }
  
  .chart-line span {
    color: rgba(0, 0, 0, var(--clarity));
  }
  
  .chart-line span.glitching {
    transition: none !important;
  }
  
  .chart-line span.glitching::before,
  .chart-line span.glitching::after {
    transition: none !important;
  }
  
  .line-1 {
    font-size: clamp(2rem, 8vw, 12rem);
  }
  
  .line-2 {
    font-size: clamp(1.6rem, 6.4vw, 9.6rem);
  }
  
  .line-3 {
    font-size: clamp(1.28rem, 5.12vw, 7.68rem);
  }
  
  .line-4 {
    font-size: clamp(1.04rem, 4.16vw, 6.24rem);
  }
  
  .line-5 {
    font-size: clamp(0.84rem, 3.36vw, 5.04rem);
  }
  
  .line-6 {
    font-size: clamp(0.68rem, 2.72vw, 4.08rem);
    position: relative;
  }
  
  .line-6::before,
  .line-6::after {
    content: '';
    position: absolute;
    height: 1px;
    background: black;
    width: clamp(50px, 15vw, 300px);
    top: 50%;
  }
  
  .line-6::before {
    right: calc(100% + clamp(1rem, 4vw, 4rem));
  }
  
  .line-6::after {
    left: calc(100% + clamp(1rem, 4vw, 4rem));
  }
  
  .line-7 {
    font-size: clamp(0.56rem, 2.24vw, 3.36rem);
  }
  
  .line-8 {
    font-size: clamp(0.44rem, 1.76vw, 2.64rem);
  }
  
  .line-9 {
    font-size: clamp(0.36rem, 1.44vw, 2.16rem);
  }
  
  .line-10 {
    font-size: clamp(0.3rem, 1.2vw, 1.8rem);
  }
  
  .line-11 {
    font-size: clamp(0.24rem, 0.96vw, 1.44rem);
    position: relative;
  }
  
  .line-11::before,
  .line-11::after {
    content: '';
    position: absolute;
    height: 1px;
    background: black;
    width: clamp(80px, 20vw, 400px);
    top: 50%;
  }
  
  .line-11::before {
    right: calc(100% + clamp(1rem, 4vw, 4rem));
  }
  
  .line-11::after {
    left: calc(100% + clamp(1rem, 4vw, 4rem));
  }
  
  .line-12 {
    font-size: clamp(0.2rem, 0.8vw, 1.2rem);
  }
  
  .line-13 {
    font-size: clamp(0.16rem, 0.64vw, 0.96rem);
  }
  
  .line-14 {
    font-size: clamp(0.14rem, 0.56vw, 0.84rem);
  }
  
  .drawer-trigger {
    cursor: pointer;
    transition: all 0.3s ease;
    padding: 0.5rem 1rem;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  
  .drawer-trigger:hover {
    transform: translateY(-2px);
  }
  
  .solid-block {
    background: #000 !important;
    color: #fff !important;
    padding: 0.8rem 2rem;
    border-radius: 4px;
    font-size: 1rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    transition: all 0.3s ease;
    min-width: 120px;
    text-align: center;
    box-shadow: none !important;
    text-shadow: none !important;
    position: relative;
  }
  
  .solid-block::before,
  .solid-block::after {
    display: none !important;
  }
  
  .drawer-trigger:hover .solid-block {
    background: #333 !important;
    transform: translateY(-1px);
  }
  
  @media (max-width: 480px) {
    .eye-chart-container {
      padding: min(3vw, 2rem);
    }
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const container = document.querySelector('.eye-chart-container');
    const letters = document.querySelectorAll('.chart-line span[data-letter]');
    const PROXIMITY_THRESHOLD = 150; // Distance in pixels for effect to start
    
    // Scramble animation on load
    const CHAR_POOL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    
    function scrambleInLetter(element: HTMLElement) {
      const finalLetter = element.getAttribute('data-original');
      const duration = 800 + Math.random() * 400; // 800-1200ms per letter
      const startTime = Date.now();
      let frameCount = 0;
      
      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        if (progress < 1) {
          // Scramble phase - change character every few frames for better effect
          frameCount++;
          if (frameCount % 3 === 0) { // Change every 3 frames
            const randomChar = CHAR_POOL[Math.floor(Math.random() * CHAR_POOL.length)];
            element.textContent = randomChar;
            element.setAttribute('data-letter', randomChar);
          }
          requestAnimationFrame(animate);
        } else {
          // Final letter
          element.textContent = finalLetter;
          element.setAttribute('data-letter', finalLetter);
        }
      }
      
      animate();
    }
    
    // Stagger the scramble animation for each letter
    letters.forEach((letter, index) => {
      // Store original letter
      const originalLetter = letter.getAttribute('data-letter');
      letter.setAttribute('data-original', originalLetter);
      
      // Set initial random character
      const randomChar = CHAR_POOL[Math.floor(Math.random() * CHAR_POOL.length)];
      letter.textContent = randomChar;
      letter.setAttribute('data-letter', randomChar);
      
      // Trigger fade in and scramble with stagger
      const delay = index * 30; // 30ms stagger between each letter
      setTimeout(() => {
        (letter as HTMLElement).style.opacity = '1';
        scrambleInLetter(letter as HTMLElement);
      }, delay);
    });
    
    function updateLetterClarity(mouseX: number, mouseY: number, _isTouchDevice = false) {
      letters.forEach(letter => {
        const rect = letter.getBoundingClientRect();
        const letterCenterX = rect.left + rect.width / 2;
        const letterCenterY = rect.top + rect.height / 2;
        
        // Calculate distance from cursor/touch to letter center
        const distance = Math.sqrt(
          Math.pow(mouseX - letterCenterX, 2) + 
          Math.pow(mouseY - letterCenterY, 2)
        );
        
        // Calculate clarity based on proximity (0 = anaglyphic, 1 = clear)
        const clarity = Math.max(0, Math.min(1, 1 - (distance / PROXIMITY_THRESHOLD)));
        
        // Apply the effect using CSS custom properties
        (letter as HTMLElement).style.setProperty('--clarity', clarity.toString());
        
        // Apply clearing class for smooth transition
        if (clarity > 0.1) {
          letter.classList.add('clearing');
        } else {
          letter.classList.remove('clearing');
        }
      });
    }
    
    // Mouse move handler for cursor devices
    container.addEventListener('mousemove', function(e: MouseEvent) {
      updateLetterClarity(e.clientX, e.clientY);
    });
    
    // Touch move handler for touch devices
    container.addEventListener('touchmove', function(e: TouchEvent) {
      e.preventDefault();
      const touch = e.touches[0];
      updateLetterClarity(touch.clientX, touch.clientY, true);
    }, { passive: false });
    
    // Touch start handler for touch devices
    container.addEventListener('touchstart', function(e: TouchEvent) {
      const touch = e.touches[0];
      updateLetterClarity(touch.clientX, touch.clientY, true);
    });
    
    // Reset when mouse leaves (cursor devices)
    container.addEventListener('mouseleave', function() {
      letters.forEach(letter => {
        letter.classList.remove('clearing');
        (letter as HTMLElement).style.removeProperty('--clarity');
      });
    });
    
    // Reset when touch ends (touch devices)
    container.addEventListener('touchend', function() {
      letters.forEach(letter => {
        letter.classList.remove('clearing');
        (letter as HTMLElement).style.removeProperty('--clarity');
      });
    });
    
    // Idle glitch effect
    let idleTimer = null;
    // let _glitchInterval: number | null = null;
    let currentGlitchingLetter = null;
    
    function startIdleGlitch() {
      // Select a random letter that's not currently being interacted with
      const availableLetters = Array.from(letters).filter(letter => 
        !letter.classList.contains('clearing') && letter.getAttribute('data-letter')
      );
      
      if (availableLetters.length === 0) return;
      
      // Clear any existing glitch
      if (currentGlitchingLetter) {
        currentGlitchingLetter.style.setProperty('--clarity', '0');
        currentGlitchingLetter.classList.remove('glitching');
      }
      
      // Pick a random letter
      currentGlitchingLetter = availableLetters[Math.floor(Math.random() * availableLetters.length)];
      currentGlitchingLetter.classList.add('glitching');
      
      // Glitch animation - oscillate clarity
      // let _glitchPhase = 0;
      const glitchDuration = 2000; // 2 seconds per glitch
      const startTime = Date.now();
      
      function animateGlitch() {
        const elapsed = Date.now() - startTime;
        
        if (elapsed < glitchDuration) {
          // Create glitchy oscillation between clear and anaglyphic
          const progress = elapsed / glitchDuration;
          const glitchValue = Math.random() > 0.5 ? 
            Math.sin(progress * Math.PI * 8) * 0.5 + 0.5 : // Smooth oscillation
            Math.random(); // Random glitch
          
          currentGlitchingLetter.style.setProperty('--clarity', glitchValue);
          requestAnimationFrame(animateGlitch);
        } else {
          // End glitch, return to anaglyphic state
          currentGlitchingLetter.style.setProperty('--clarity', '0');
          currentGlitchingLetter.classList.remove('glitching');
          
          // Schedule next glitch after a pause
          setTimeout(() => {
            if (idleTimer) startIdleGlitch();
          }, 1000 + Math.random() * 2000); // 1-3 seconds between glitches
        }
      }
      
      animateGlitch();
    }
    
    function resetIdleTimer() {
      // Clear existing timers
      if (idleTimer) {
        clearTimeout(idleTimer);
        idleTimer = null;
      }
      
      // Stop any active glitching
      if (currentGlitchingLetter) {
        currentGlitchingLetter.style.setProperty('--clarity', '0');
        currentGlitchingLetter.classList.remove('glitching');
        currentGlitchingLetter = null;
      }
      
      // Start new idle timer
      idleTimer = setTimeout(() => {
        startIdleGlitch();
      }, 3000); // 3 seconds of idle before glitching starts
    }
    
    // Track user activity
    container.addEventListener('mousemove', resetIdleTimer);
    container.addEventListener('mouseenter', resetIdleTimer);
    container.addEventListener('touchstart', resetIdleTimer);
    container.addEventListener('touchmove', resetIdleTimer);
    document.addEventListener('click', resetIdleTimer);
    
    // Start the idle timer initially
    resetIdleTimer();
  });
</script>